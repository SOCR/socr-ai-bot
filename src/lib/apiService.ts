// Service for making API calls to the backend R server
import { executeRCode as webRExecuteCode } from './webr';
import { apiKeyStorage } from './utils';

interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  error?: string;
}

export interface CodeChunk {
  id: string;
  title: string;
  code: string;
  output?: string;
  plot?: string;
  tabSource: string;
  timestamp: number;
}

class ApiService {
  private baseUrl: string;
  private generatedCode: CodeChunk[] = [];
  
  constructor() {
    // In a real implementation, this would be environment-dependent
    this.baseUrl = 'https://api.example.com/r-server';
  }
  
  setApiKey(key: string) {
    apiKeyStorage.setOpenAIApiKey(key);
  }
  
  getApiKey(): string | null {
    return apiKeyStorage.getOpenAIApiKey();
  }
  
  setTemperature(temp: number) {
    apiKeyStorage.setTemperature(temp);
  }
  
  getTemperature(): number {
    return apiKeyStorage.getTemperature();
  }
  
  // Method to add generated code to our store
  addGeneratedCode(codeChunk: Omit<CodeChunk, 'id' | 'timestamp'>) {
    const newCodeChunk: CodeChunk = {
      ...codeChunk,
      id: `chunk-${Date.now()}-${Math.floor(Math.random() * 1000)}`,
      timestamp: Date.now()
    };
    
    this.generatedCode.push(newCodeChunk);
    console.log('Code added to store:', newCodeChunk);
    return newCodeChunk;
  }
  
  // Method to get all generated code
  getAllGeneratedCode(): CodeChunk[] {
    return [...this.generatedCode];
  }
  
  // Method to get generated code from a specific tab
  getGeneratedCodeByTab(tabSource: string): CodeChunk[] {
    return this.generatedCode.filter(chunk => chunk.tabSource === tabSource);
  }
  
  // Method to clear all generated code
  clearGeneratedCode() {
    this.generatedCode = [];
  }
  
  private async fetchWithAuth(endpoint: string, options: RequestInit = {}): Promise<Response> {
    const headers = {
      'Content-Type': 'application/json',
      ...(this.getApiKey() ? { 'Authorization': `Bearer ${this.getApiKey()}` } : {}),
      ...(options.headers || {})
    };
    
    return fetch(`${this.baseUrl}${endpoint}`, {
      ...options,
      headers
    });
  }
  
  async executeRCode(code: string, data?: any, options?: { tabSource?: string; title?: string; isGenAIGenerated?: boolean }): Promise<ApiResponse> {
    try {
      console.log('Executing R code with WebR:', code);
      
      // Extract dataset name and uploaded data
      let datasetName = null;
      let uploadedData = null;
      
      if (data) {
        if (typeof data === 'string') {
          datasetName = data;
        } else {
          uploadedData = data;
        }
      }
      
      // Execute the code using WebR
      const result = await webRExecuteCode(code, datasetName, uploadedData);
      
      // Store the code if tabSource is provided AND it's marked as generated by GenAI
      if (options?.tabSource && options?.isGenAIGenerated === true) {
        this.addGeneratedCode({
          title: options.title || 'R Code Execution',
          code,
          output: result.output || '',
          plot: result.plot || undefined,
          tabSource: options.tabSource
        });
      }
      
      if (result.success) {
        return {
          success: true,
          data: {
            result: result.output || 'R code executed successfully',
            plot: result.plot || null,
            output: result.output || ''
          }
        };
      } else {
        return {
          success: false,
          error: result.error || 'Error executing R code'
        };
      }
    } catch (error) {
      console.error('Error executing R code:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }
  
  async generateSyntheticText(prompt: string): Promise<ApiResponse<string>> {
    const apiKey = this.getApiKey();
    if (!apiKey) {
      return {
        success: false,
        error: 'API key not set. Please add your API key in Settings.'
      };
    }
    
    try {
      // In a real implementation, this would call an AI API
      console.log('Generating synthetic text for prompt:', prompt);
      
      // Simulate a response
      return {
        success: true,
        data: `This is a synthetic text response to: "${prompt}". In a real implementation, this would be generated by an AI model.`
      };
    } catch (error) {
      console.error('Error generating synthetic text:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }
  
  async generateSyntheticImage(prompt: string): Promise<ApiResponse<string>> {
    const apiKey = this.getApiKey();
    if (!apiKey) {
      return {
        success: false,
        error: 'API key not set. Please add your API key in Settings.'
      };
    }
    
    try {
      // In a real implementation, this would call an AI API
      console.log('Generating synthetic image for prompt:', prompt);
      
      // Simulate a response with a placeholder image
      return {
        success: true,
        data: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg=='
      };
    } catch (error) {
      console.error('Error generating synthetic image:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }
}

// Create and export a singleton instance
const apiService = new ApiService();
export default apiService;
